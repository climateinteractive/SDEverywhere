// Copyright (c) 2020-2022 Climate Interactive / New Venture Fund

import type { ConstantDef, OutputVarId } from '../_shared'
import type { RunModelParams, RunnableModel } from '../runnable-model'
import { perfElapsed, perfNow } from '../perf'
import { createFloat64WasmBuffer, createInt32WasmBuffer, type WasmBuffer } from './wasm-buffer'
import type { WasmModule } from './wasm-module'

/**
 * A wrapper around a WebAssembly module generated by the SDEverywhere transpiler,
 * which allows for running the model with a given set of input values, producing
 * a set of output values.
 */
class WasmModel implements RunnableModel {
  // from RunnableModel interface
  public readonly startTime: number
  // from RunnableModel interface
  public readonly endTime: number
  // from RunnableModel interface
  public readonly saveFreq: number
  // from RunnableModel interface
  public readonly numSavePoints: number
  // from RunnableModel interface
  public readonly outputVarIds: OutputVarId[]
  // from RunnableModel interface
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public readonly modelListing?: any

  // Reuse the wasm buffers.  These buffers are allocated on demand and grown
  // (reallocated) as needed.
  private inputsBuffer: WasmBuffer<Float64Array>
  private outputsBuffer: WasmBuffer<Float64Array>
  private outputIndicesBuffer: WasmBuffer<Int32Array>
  private lookupDataBuffer: WasmBuffer<Float64Array>
  private lookupSubIndicesBuffer: WasmBuffer<Int32Array>

  private readonly wasmSetLookup: (
    varIndex: number,
    subIndicesAddress: number,
    pointsAddress: number,
    numPoints: number
  ) => void
  private readonly wasmSetConstant: (varIndex: number, subIndicesAddress: number, value: number) => void
  private readonly wasmRunModel: (inputsAddress: number, outputsAddress: number, outputIndicesAddress: number) => void

  /**
   * @param wasmModule The `WasmModule` that provides access to the native functions.
   * @param outputVarIds The output variable IDs for this model.
   */
  constructor(private readonly wasmModule: WasmModule) {
    function getNumberValue(funcName: string): number {
      const wasmGetValue: () => number = wasmModule.cwrap(funcName, 'number', [])
      return wasmGetValue()
    }
    this.startTime = getNumberValue('getInitialTime')
    this.endTime = getNumberValue('getFinalTime')
    this.saveFreq = getNumberValue('getSaveper')

    // Each series will include one data point per "save", inclusive of the
    // start and end times
    this.numSavePoints = Math.round((this.endTime - this.startTime) / this.saveFreq) + 1
    this.outputVarIds = wasmModule.outputVarIds

    // Expose the model listing, if it was bundled with the generated module
    this.modelListing = wasmModule.modelListing

    // Make the native functions callable
    this.wasmSetLookup = wasmModule.cwrap('setLookup', null, ['number', 'number', 'number', 'number'])
    this.wasmSetConstant = wasmModule.cwrap('setConstant', null, ['number', 'number', 'number'])
    this.wasmRunModel = wasmModule.cwrap('runModelWithBuffers', null, ['number', 'number', 'number'])
  }

  // from RunnableModel interface
  runModel(params: RunModelParams): void {
    // Note that for wasm models, we always need to allocate `WasmBuffer` instances to
    // and copy data to/from them because only that kind of buffer can be passed to
    // the `wasmRunModel` function.

    // Apply lookup overrides, if provided
    const lookups = params.getLookups()
    if (lookups !== undefined) {
      for (const lookupDef of lookups) {
        // Copy the subscript index values to the `WasmBuffer`.  If we don't have an
        // existing `WasmBuffer`, or the existing one is not big enough, allocate a new one.
        const varSpec = lookupDef.varRef.varSpec
        const numSubElements = varSpec.subscriptIndices?.length || 0
        let subIndicesAddress: number
        if (numSubElements > 0) {
          if (this.lookupSubIndicesBuffer === undefined || this.lookupSubIndicesBuffer.numElements < numSubElements) {
            this.lookupSubIndicesBuffer?.dispose()
            this.lookupSubIndicesBuffer = createInt32WasmBuffer(this.wasmModule, numSubElements)
          }
          this.lookupSubIndicesBuffer.getArrayView().set(varSpec.subscriptIndices)
          subIndicesAddress = this.lookupSubIndicesBuffer.getAddress()
        } else {
          subIndicesAddress = 0
        }

        let pointsAddress: number
        let numPoints: number
        if (lookupDef.points) {
          // Copy the lookup data to the `WasmBuffer`.  If we don't have an existing `WasmBuffer`,
          // or the existing one is not big enough, allocate a new one.
          const numLookupElements = lookupDef.points.length
          if (this.lookupDataBuffer === undefined || this.lookupDataBuffer.numElements < numLookupElements) {
            this.lookupDataBuffer?.dispose()
            this.lookupDataBuffer = createFloat64WasmBuffer(this.wasmModule, numLookupElements)
          }
          this.lookupDataBuffer.getArrayView().set(lookupDef.points)
          pointsAddress = this.lookupDataBuffer.getAddress()

          // Note that the native `numPoints` argument is the number of (x,y) pairs, so divide
          // the length of the flat points array by two
          numPoints = numLookupElements / 2
        } else {
          // In the case where the points array is undefined, we pass 0 (NULL), which will reset
          // the lookup to its original data
          pointsAddress = 0
          numPoints = 0
        }

        // Call the native `setLookup` function
        const varIndex = varSpec.varIndex
        this.wasmSetLookup(varIndex, subIndicesAddress, pointsAddress, numPoints)
      }
    }

    // Apply constant overrides, if provided
    const constants = params.getConstants()
    if (constants !== undefined) {
      for (const constantDef of constants) {
        const varSpec = constantDef.varRef.varSpec
        const numSubElements = varSpec.subscriptIndices?.length || 0
        let subIndicesAddress: number

        if (numSubElements > 0) {
          // Reuse the lookup sub indices buffer for constants
          if (this.lookupSubIndicesBuffer === undefined || this.lookupSubIndicesBuffer.numElements < numSubElements) {
            this.lookupSubIndicesBuffer?.dispose()
            this.lookupSubIndicesBuffer = createInt32WasmBuffer(this.wasmModule, numSubElements)
          }
          this.lookupSubIndicesBuffer.getArrayView().set(varSpec.subscriptIndices)
          subIndicesAddress = this.lookupSubIndicesBuffer.getAddress()
        } else {
          subIndicesAddress = 0
        }

        // Call the native `setConstant` function
        const varIndex = varSpec.varIndex
        this.wasmSetConstant(varIndex, subIndicesAddress, constantDef.value)
      }
    }

    // Copy the inputs to the `WasmBuffer`.  If we don't have an existing `WasmBuffer`,
    // or the existing one is not big enough, the callback will allocate a new one.
    params.copyInputs(this.inputsBuffer?.getArrayView(), numElements => {
      this.inputsBuffer?.dispose()
      this.inputsBuffer = createFloat64WasmBuffer(this.wasmModule, numElements)
      return this.inputsBuffer.getArrayView()
    })

    let outputIndicesBuffer: WasmBuffer<Int32Array>
    if (params.getOutputIndicesLength() > 0) {
      // Copy the output indices (if needed) to the `WasmBuffer`.  If we don't have an
      // existing `WasmBuffer`, or the existing one is not big enough, the callback
      // will allocate a new one.
      params.copyOutputIndices(this.outputIndicesBuffer?.getArrayView(), numElements => {
        this.outputIndicesBuffer?.dispose()
        this.outputIndicesBuffer = createInt32WasmBuffer(this.wasmModule, numElements)
        return this.outputIndicesBuffer.getArrayView()
      })
      outputIndicesBuffer = this.outputIndicesBuffer
    } else {
      // The output indices are not active
      outputIndicesBuffer = undefined
    }

    // Allocate (or reallocate) the `WasmBuffer` that will receive the outputs
    const outputsLengthInElements = params.getOutputsLength()
    if (this.outputsBuffer === undefined || this.outputsBuffer.numElements < outputsLengthInElements) {
      this.outputsBuffer?.dispose()
      this.outputsBuffer = createFloat64WasmBuffer(this.wasmModule, outputsLengthInElements)
    }

    // Run the model
    const t0 = perfNow()
    this.wasmRunModel(
      this.inputsBuffer?.getAddress() || 0,
      this.outputsBuffer.getAddress(),
      outputIndicesBuffer?.getAddress() || 0
    )
    const elapsed = perfElapsed(t0)

    // Copy the outputs that were stored into the `WasmBuffer` back to the `RunModelParams`
    params.storeOutputs(this.outputsBuffer.getArrayView())

    // Store the elapsed time in the `RunModelParams`
    params.storeElapsedTime(elapsed)
  }

  // from RunnableModel interface
  terminate(): void {
    this.inputsBuffer?.dispose()
    this.inputsBuffer = undefined

    this.outputsBuffer?.dispose()
    this.outputsBuffer = undefined

    this.outputIndicesBuffer?.dispose()
    this.outputIndicesBuffer = undefined

    // TODO: Dispose the `WasmModule` too?
  }
}

/**
 * Initialize the wasm model.
 *
 * @hidden This is not part of the public API; only the top-level `createRunnableModel`
 * function is exposed in the public API.
 *
 * @param wasmModule The `WasmModule` that wraps the `wasm` binary.
 * @return The initialized `WasmModel` instance.
 */
export function initWasmModel(wasmModule: WasmModule): RunnableModel {
  return new WasmModel(wasmModule)
}
