// Copyright (c) 2024 Climate Interactive / New Venture Fund

import { type InputValue, Outputs } from '../_shared'

import { type JsModel, initJsModel } from '../js-model'
import { type WasmModule, initWasmModel } from '../wasm-model'
import { type RunnableModel, ReferencedRunModelParams } from '../runnable-model'

import type { ModelRunner } from './model-runner'

/**
 * Create a `RunnableModel` from a given `JsModel` or `WasmModule` that was generated by the
 * SDEverywhere transpiler/builder.
 *
 * @hidden This is not yet part of the public API; it is only exposed for use by
 * the runtime-async package.
 */
export function createRunnableModel(generatedModel: JsModel | WasmModule): RunnableModel {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  if ((generatedModel as any)['setModelFunctions'] !== undefined) {
    // Assume it's a `JsModel`
    return initJsModel(generatedModel as JsModel)
  } else {
    // Otherwise, assume it's a `WasmModule`
    return initWasmModel(generatedModel as WasmModule)
  }
}

/**
 * Create a `ModelRunner` that runs a generated model on the JS thread.
 *
 * @param generatedModel A `JsModel` or `WasmModule` generated by the SDEverywhere transpiler.
 */
export function createSynchronousModelRunner(generatedModel: JsModel | WasmModule): ModelRunner {
  const runnableModel = createRunnableModel(generatedModel)
  return createRunnerFromRunnableModel(runnableModel)
}

/**
 * Create a `ModelRunner` that runs the given model on the JS thread.
 *
 * @param model The runnable model instance.
 */
function createRunnerFromRunnableModel(model: RunnableModel): ModelRunner {
  // Maintain a `ReferencedRunModelParams` instance that holds the I/O parameters
  const params = new ReferencedRunModelParams()

  // Disallow `runModel` after the runner has been terminated
  let terminated = false

  const runModelSync = (inputs: (InputValue | number)[], outputs: Outputs) => {
    // Update the I/O parameters
    params.updateFromParams(inputs, outputs)

    // Run the model synchronously using those parameters
    model.runModel(params)

    return outputs
  }

  return {
    createOutputs: () => {
      return new Outputs(model.outputVarIds, model.startTime, model.endTime, model.saveFreq)
    },

    runModel: (inputs, outputs) => {
      if (terminated) {
        return Promise.reject(new Error('Model runner has already been terminated'))
      }
      return Promise.resolve(runModelSync(inputs, outputs))
    },

    runModelSync: (inputs, outputs) => {
      if (terminated) {
        throw new Error('Model runner has already been terminated')
      }
      return runModelSync(inputs, outputs)
    },

    terminate: async () => {
      if (!terminated) {
        model.terminate()
        terminated = true
      }
    }
  }
}
