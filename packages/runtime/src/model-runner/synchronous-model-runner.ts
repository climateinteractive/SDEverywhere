// Copyright (c) 2024 Climate Interactive / New Venture Fund

import { type InputValue, Outputs } from '../_shared'

import { type JsModel, initJsModel } from '../js-model'
import { type WasmModule, initWasmModel } from '../wasm-model'
import type { RunnableModel, RunModelOptions } from '../runnable-model'
import { ReferencedRunModelParams } from '../runnable-model'

import type { ModelRunner } from './model-runner'
import { ModelListing } from '../model-listing'

/** Union of model types that are generated by the SDEverywhere transpiler/builder. */
export type GeneratedModel = JsModel | WasmModule

/**
 * Create a `RunnableModel` from a given `JsModel` or `WasmModule` that was generated by the
 * SDEverywhere transpiler/builder.
 *
 * @hidden This is not yet part of the public API; it is only exposed for use by
 * the runtime-async package.
 */
export function createRunnableModel(generatedModel: GeneratedModel): RunnableModel {
  switch (generatedModel.kind) {
    case 'js':
      // Assume it's a `JsModel`
      return initJsModel(generatedModel)
    case 'wasm':
      // Assume it's a `WasmModule`
      return initWasmModel(generatedModel)
    default:
      throw new Error(`Unable to identify generated model kind`)
  }
}

/**
 * Create a `ModelRunner` that runs a generated model on the JS thread.
 *
 * @param generatedModel A `JsModel` or `WasmModule` generated by the SDEverywhere transpiler.
 */
export function createSynchronousModelRunner(generatedModel: GeneratedModel): ModelRunner {
  const runnableModel = createRunnableModel(generatedModel)
  return createRunnerFromRunnableModel(runnableModel)
}

/**
 * Create a `ModelRunner` that runs the given model on the JS thread.
 *
 * @param model The runnable model instance.
 */
function createRunnerFromRunnableModel(model: RunnableModel): ModelRunner {
  // Maintain a `ReferencedRunModelParams` instance that holds the I/O parameters
  const listing = model.modelListing ? new ModelListing(model.modelListing) : undefined
  const params = new ReferencedRunModelParams(listing)

  // Disallow `runModel` after the runner has been terminated
  let terminated = false

  const runModelSync = (inputs: number[] | InputValue[], outputs: Outputs, options: RunModelOptions | undefined) => {
    // Update the I/O parameters
    params.updateFromParams(inputs, outputs, options)

    // Run the model synchronously using those parameters
    model.runModel(params)

    return outputs
  }

  return {
    createOutputs: () => {
      return new Outputs(model.outputVarIds, model.startTime, model.endTime, model.saveFreq)
    },

    runModel: (inputs, outputs, options) => {
      if (terminated) {
        return Promise.reject(new Error('Model runner has already been terminated'))
      }
      return Promise.resolve(runModelSync(inputs, outputs, options))
    },

    runModelSync: (inputs, outputs, options) => {
      if (terminated) {
        throw new Error('Model runner has already been terminated')
      }
      return runModelSync(inputs, outputs, options)
    },

    terminate: async () => {
      if (!terminated) {
        model.terminate()
        terminated = true
      }
    }
  }
}
