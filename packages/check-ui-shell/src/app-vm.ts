// Copyright (c) 2021-2022 Climate Interactive / New Venture Fund

import assertNever from 'assert-never'

import type { Readable, Writable } from 'svelte/store'
import { get, writable } from 'svelte/store'

import type {
  CheckNameSpec,
  CheckReport,
  ComparisonReport,
  ComparisonScenarioTitleSpec,
  ComparisonSummary,
  ScenarioSpec,
  SuiteSummary
} from '@sdeverywhere/check-core'
import { checkReportFromSummary, comparisonSummaryFromReport, runSuite } from '@sdeverywhere/check-core'

import { localStorageWritableBoolean, localStorageWritableNumber } from './_shared/stores'
import type { UserPrefs } from './_shared/user-prefs'

import type { AppModel } from './model/app-model'

import type { ComparisonGroupingKind } from './components/compare/_shared/comparison-grouping-kind'
import { type PinnedItemStates } from './components/compare/_shared/pinned-item-state'
import { createPinnedItemStates } from './components/compare/_shared/pinned-item-state'
import type { CompareDetailViewModel } from './components/compare/detail/compare-detail-vm'
import {
  createCompareDetailViewModelForScenario,
  createCompareDetailViewModelForDataset,
  createCompareDetailViewModelForFreeformView,
  createCompareDetailViewModelForUnresolvedView
} from './components/compare/detail/compare-detail-vm'
import type { ComparisonSummaryRowViewModel } from './components/compare/summary/comparison-summary-row-vm'
import type { ComparisonSummaryViewModel } from './components/compare/summary/comparison-summary-vm'
import type { FilterItem, FilterStateMap, FilterStates } from './components/filter/filter-panel-vm'
import { createFilterPanelViewModel } from './components/filter/filter-panel-vm'
import type { FilterPopoverViewModel } from './components/filter/filter-popover-vm'
import type { HeaderViewModel } from './components/header/header-vm'
import { createHeaderViewModel } from './components/header/header-vm'
import type { PerfViewModel } from './components/perf/perf-vm'
import { createPerfViewModel } from './components/perf/perf-vm'
import type { SummaryViewModel } from './components/summary/summary-vm'
import { createSummaryViewModel } from './components/summary/summary-vm'
import { type TraceViewModel, createTraceViewModel } from './components/trace/trace-vm'

export interface RunSuiteCallbacks {
  onProgress?: (pct: number) => void
  onComplete?: () => void
}

export class AppViewModel {
  private readonly writableChecksInProgress: Writable<boolean>
  public readonly checksInProgress: Readable<boolean>
  private readonly writableProgress: Writable<string>
  public readonly progress: Readable<string>
  public readonly userPrefs: UserPrefs
  public readonly headerViewModel: HeaderViewModel
  private readonly pinnedItemStates: PinnedItemStates
  public summaryViewModel: SummaryViewModel
  public filterPopoverViewModel: FilterPopoverViewModel
  private cancelRunSuite: () => void
  private skipChecks: CheckNameSpec[]
  private skipComparisonScenarios: ComparisonScenarioTitleSpec[]

  /**
   * @param appModel The app model.
   * @param suiteSummary The test suite summary if one was already generated by
   * model-check CLI tool during the build process; if defined, this will be used
   * instead of running the checks and comparisons in the user's browser.
   */
  constructor(
    private readonly appModel: AppModel,
    private readonly suiteSummary?: SuiteSummary
  ) {
    this.writableChecksInProgress = writable(true)
    this.checksInProgress = this.writableChecksInProgress
    this.writableProgress = writable('0%')
    this.progress = this.writableProgress

    // Create the `UserPrefs` object that is passed down to the component hierarchy
    const zoom = localStorageWritableNumber('sde-check-graph-zoom', 1)
    const consistentYRange = localStorageWritableBoolean('sde-check-consistent-y-range', false)
    this.userPrefs = {
      zoom,
      consistentYRange
    }

    // Create the header view model
    this.headerViewModel = createHeaderViewModel(appModel.config.comparison, zoom, consistentYRange)

    // Create the object that manages pinned items states
    this.pinnedItemStates = createPinnedItemStates()

    // Load check filter states from LocalStorage
    if (import.meta.hot) {
      const checkStatesJson = localStorage.getItem('sde-check-filter-states')
      const checkStates: FilterStates = checkStatesJson ? JSON.parse(checkStatesJson) : {}
      this.skipChecks = Object.keys(checkStates)
        .filter(key => {
          const state = checkStates[key]
          return state && state.checked === false
        })
        .map(key => {
          const state = checkStates[key]
          return {
            groupName: state.titleParts?.groupName || '',
            testName: state.titleParts?.testName || ''
          }
        })
    } else {
      this.skipChecks = []
    }

    // Load comparison scenario filter states from LocalStorage
    if (import.meta.hot) {
      const scenarioStatesJson = localStorage.getItem('sde-comparison-scenario-filter-states')
      const scenarioStates: FilterStates = scenarioStatesJson ? JSON.parse(scenarioStatesJson) : {}
      this.skipComparisonScenarios = Object.keys(scenarioStates)
        .filter(key => {
          const state = scenarioStates[key]
          return state && state.checked === false
        })
        .map(key => {
          const state = scenarioStates[key]
          return {
            title: state.titleParts?.title || '',
            subtitle: state.titleParts?.subtitle
          }
        })
    } else {
      this.skipComparisonScenarios = []
    }
  }

  private saveCheckFilterStatesToLocalStorage(json: string): void {
    try {
      localStorage.setItem('sde-check-filter-states', json)
    } catch (error) {
      console.warn('Failed to save check filter states to LocalStorage:', error)
    }
  }

  private saveComparisonScenarioFilterStatesToLocalStorage(json: string): void {
    try {
      localStorage.setItem('sde-comparison-scenario-filter-states', json)
    } catch (error) {
      console.warn('Failed to save comparison scenario filter states to LocalStorage:', error)
    }
  }

  runTestSuite(): void {
    // If a run is already in progress, cancel it before starting a new run
    if (this.cancelRunSuite) {
      this.cancelRunSuite()
      this.cancelRunSuite = undefined
    }

    // Reset the progress state
    this.writableChecksInProgress.set(true)
    this.writableProgress.set('0%')

    const comparisonConfig = this.appModel.config.comparison
    if (this.suiteSummary) {
      // For the case where checks were run ahead of time using the model-check
      // CLI tool, we can display the report immediately instead of running all
      // the checks in the user's browser
      const checkConfig = this.appModel.config.check
      const checkReport = checkReportFromSummary(checkConfig, this.suiteSummary.checkSummary)
      const comparisonSummary = this.suiteSummary?.comparisonSummary
      this.summaryViewModel = createSummaryViewModel(
        this.appModel.checkDataCoordinator,
        checkReport,
        comparisonConfig,
        comparisonSummary,
        this.pinnedItemStates
      )
      this.writableChecksInProgress.set(false)
    } else {
      // For local dev builds, run the test suite in the browser
      this.cancelRunSuite = runSuite(
        this.appModel.config,
        {
          onProgress: pct => {
            this.writableProgress.set(`${Math.round(pct * 100)}%`)
          },
          onComplete: report => {
            const checkReport = report.checkReport
            let comparisonSummary: ComparisonSummary
            if (report.comparisonReport) {
              comparisonSummary = comparisonSummaryFromReport(report.comparisonReport)
            }
            this.summaryViewModel = createSummaryViewModel(
              this.appModel.checkDataCoordinator,
              checkReport,
              comparisonConfig,
              comparisonSummary,
              this.pinnedItemStates
            )
            this.filterPopoverViewModel = this.createFilterPopoverViewModel(checkReport, report.comparisonReport)
            this.writableChecksInProgress.set(false)
          },
          onError: error => {
            // TODO: Show error message in browser
            console.error(error)
          }
        },
        {
          skipChecks: this.skipChecks,
          skipComparisonScenarios: this.skipComparisonScenarios
        }
      )
    }
  }

  createCompareDetailViewModelForSummaryRow(
    summaryRowViewModel: ComparisonSummaryRowViewModel
  ): CompareDetailViewModel {
    const groupSummary = summaryRowViewModel.groupSummary

    const viewGroup = summaryRowViewModel.viewMetadata?.viewGroup
    const view = summaryRowViewModel.viewMetadata?.view

    if (view?.kind === 'unresolved-view') {
      return createCompareDetailViewModelForUnresolvedView(summaryRowViewModel.rowKey, viewGroup, view)
    }

    if (groupSummary !== undefined) {
      if (groupSummary.group.kind === 'by-dataset') {
        // Show the detail view for the given dataset summary item, with pinned
        // scenarios at the top of the detail view
        return createCompareDetailViewModelForDataset(
          summaryRowViewModel.rowKey,
          this.appModel.config.comparison,
          this.appModel.comparisonDataCoordinator,
          this.userPrefs,
          groupSummary,
          this.pinnedItemStates.pinnedScenarios
        )
      } else {
        // Show the detail view for the given scenario (or view) summary item,
        // with pinned datasets at the top of the detail view
        return createCompareDetailViewModelForScenario(
          summaryRowViewModel.rowKey,
          this.appModel.config.comparison,
          this.appModel.comparisonDataCoordinator,
          this.userPrefs,
          groupSummary,
          viewGroup,
          view,
          this.pinnedItemStates.pinnedDatasets
        )
      }
    } else {
      // Show the detail view for the given freeform view
      return createCompareDetailViewModelForFreeformView(
        summaryRowViewModel.rowKey,
        this.appModel.config.comparison,
        this.appModel.comparisonDataCoordinator,
        this.userPrefs,
        viewGroup,
        view,
        this.pinnedItemStates.pinnedFreeformRows
      )
    }
  }

  createCompareDetailViewModelForFirstSummaryRow(kind: ComparisonGroupingKind): CompareDetailViewModel | undefined {
    // Get the index of the associated row in the context of the summary view
    const comparisonSummaryViewModel = this.getComparisonSummaryViewModel(kind)
    const allRows = get(comparisonSummaryViewModel.allRows)
    if (allRows.length > 0) {
      // Create a detail view for the first row
      const firstRow = allRows[0]
      return this.createCompareDetailViewModelForSummaryRow(firstRow)
    } else {
      return undefined
    }
  }

  createCompareDetailViewModelForSummaryRowWithDelta(
    kind: ComparisonGroupingKind,
    summaryRowKey: string,
    delta: -1 | 1
  ): CompareDetailViewModel | undefined {
    // Get the index of the associated row in the context of the summary view
    const comparisonSummaryViewModel = this.getComparisonSummaryViewModel(kind)
    const allRows = get(comparisonSummaryViewModel.allRows)
    const rowIndex = allRows.findIndex(row => row.rowKey === summaryRowKey)
    const adjRowIndex = rowIndex + delta
    if (adjRowIndex >= 0 && adjRowIndex < allRows.length) {
      // Create a detail view for the adjacent row
      const prevRow = allRows[adjRowIndex]
      return this.createCompareDetailViewModelForSummaryRow(prevRow)
    } else {
      return undefined
    }
  }

  private getComparisonSummaryViewModel(kind: ComparisonGroupingKind): ComparisonSummaryViewModel {
    switch (kind) {
      case 'views':
        return this.summaryViewModel.comparisonViewsSummaryViewModel
      case 'by-scenario':
        return this.summaryViewModel.comparisonsByScenarioSummaryViewModel
      case 'by-dataset':
        return this.summaryViewModel.comparisonsByDatasetSummaryViewModel
      default:
        assertNever(kind)
    }
  }

  createPerfViewModel(): PerfViewModel {
    return createPerfViewModel(this.appModel.config)
  }

  createTraceViewModel(checkScenarioSpec?: ScenarioSpec): TraceViewModel {
    const comparisonConfig = this.appModel.config.comparison
    const dataCoordinator = this.appModel.comparisonDataCoordinator
    const testSummaries = this.summaryViewModel.comparisonSummary?.testSummaries ?? []
    return createTraceViewModel(comparisonConfig, dataCoordinator, testSummaries, checkScenarioSpec)
  }

  // createFreeformViewModel(): FreeformViewModel {
  //   if (this.appModel.config.comparison === undefined) {
  //     // TODO: Error message
  //     return
  //   }
  //   return createFreeformViewModel(this.appModel.config.comparison, this.appModel.comparisonDataCoordinator)
  //   }

  private createFilterPopoverViewModel(
    checkReport: CheckReport,
    comparisonReport?: ComparisonReport
  ): FilterPopoverViewModel {
    // Extract check items from the check report
    const checkItems: FilterItem[] = []
    const checkStates: FilterStateMap = new Map()
    for (const group of checkReport.groups) {
      const groupChildren: FilterItem[] = []

      for (const test of group.tests) {
        const testKey = `${group.name}__${test.name}`
        groupChildren.push({
          key: testKey,
          titleParts: {
            groupName: group.name,
            testName: test.name
          },
          label: test.name
        })

        // Set initial state based on whether this test was skipped
        checkStates.set(testKey, test.status !== 'skipped')
      }

      if (groupChildren.length > 0) {
        checkItems.push({
          key: group.name,
          label: group.name,
          children: groupChildren
        })
      }
    }

    // Extract comparison scenario items from the comparison report
    const scenarioItems: FilterItem[] = []
    const scenarioStates: FilterStateMap = new Map()
    if (comparisonReport) {
      // Group scenarios by title to avoid duplicates
      const scenarioMap = new Map<string, { title: string; subtitle?: string; skipped: boolean }>()
      const allScenarios = Array.from(this.appModel.config.comparison?.scenarios.getAllScenarios() || [])

      for (const testReport of comparisonReport.testReports) {
        // Find the scenario details from the config
        const scenario = allScenarios.find(s => s.key === testReport.scenarioKey)
        if (scenario) {
          const key = scenario.subtitle ? `${scenario.title}__${scenario.subtitle}` : scenario.title
          if (!scenarioMap.has(key)) {
            scenarioMap.set(key, {
              title: scenario.title,
              subtitle: scenario.subtitle,
              skipped: testReport.diffReport === undefined
            })
          }
        }
      }

      for (const [key, scenario] of scenarioMap) {
        scenarioItems.push({
          key,
          titleParts: {
            title: scenario.title,
            subtitle: scenario.subtitle
          },
          label: scenario.subtitle ? `${scenario.title} ${scenario.subtitle}` : scenario.title
        })

        // Set initial state based on whether this scenario was skipped
        scenarioStates.set(key, !scenario.skipped)
      }
    }

    const checksPanel = createFilterPanelViewModel(checkItems, checkStates, states =>
      this.saveCheckFilterStatesToLocalStorage(JSON.stringify(states))
    )

    const comparisonScenariosPanel = createFilterPanelViewModel(scenarioItems, scenarioStates, states =>
      this.saveComparisonScenarioFilterStatesToLocalStorage(JSON.stringify(states))
    )

    return {
      checksPanel,
      comparisonScenariosPanel
    }
  }

  applyFilters(): void {
    // When the "Apply and Run" button is clicked, dispatch an event that will be handled
    // at a higher level to reload the UI and run the tests again using the new filters
    document.dispatchEvent(new CustomEvent('sde-check-apply-filters'))
  }
}

export interface AppViewModelResult {
  viewModel?: AppViewModel
  error?: Error
}
