// Copyright (c) 2025 Climate Interactive / New Venture Fund

import type { ImplVar } from './var-types'

/**
 * A terse representation of a subscript.
 */
export interface EncodedSubscript {
  /** The subscript name (e.g., "Sub1"). */
  n: string
  /** The subscript identifier (e.g., "_sub1"). */
  i: string
}

/**
 * A terse representation of a variable without subscripts.
 */
export interface EncodedVariable {
  /** The variable name (corresponds to the base part of `ImplVar.varName` without subscripts). */
  n: string
  /** The variable identifier (corresponds to the base part of `ImplVar.varId` without subscripts). */
  i: string
  /** The variable index (corresponds to `ImplVar.varIndex`). */
  x: number
}

/**
 * A terse representation of a variable type.
 */
export type EncodedVarType = string

/**
 * A terse representation of a variable instance as a flat array.
 *
 * Format: [t, v, si0, si1, ..., sx0, sx1, ...]
 * - Element 0: The index of the associated `EncodedVarType` element in the `varTypes` array (corresponds to `ImplVar.varType`).
 * - Element 1: The index of the associated `EncodedVariable` element in the `variables` array.
 * - Elements 2+: If subscripts are present, first all subscript element indices, then all subscript indices:
 *   - Elements 2 to (2 + n - 1): The indices of the associated `EncodedSubscript` elements in the `subscripts` array.
 *   - Elements (2 + n) to (2 + 2n - 1): The subscript index values (corresponds to `ImplVar.subscriptIndices`).
 */
export type EncodedVarInstance = number[]

/**
 * The encoded representation of impl variables that eliminates redundancy.
 */
export interface EncodedImplVars {
  subscripts: EncodedSubscript[]
  variables: EncodedVariable[]
  varTypes: EncodedVarType[]
  varInstances: {
    [key: string]: EncodedVarInstance[]
  }
}

/**
 * Encode impl variable metadata into a more efficient format.
 *
 * This is used to reduce the size of a bundle by eliminating redundancy in variable/subscript
 * names and identifiers.  The `varInstances` object in the model listing JSON generated by the
 * compiler includes verbose information for each variable instance.  This function puts that
 * information into a more efficient format that can be bundled as a normal JavaScript object
 * in the model-check bundle file, and then decoded and expandedwhen the bundle is loaded.
 *
 * @param input The input structure mapping keys to ImplVar arrays.
 * @returns The encoded representation.
 */
export function encodeImplVars(input: { [key: string]: ImplVar[] }): EncodedImplVars {
  const subscripts: EncodedSubscript[] = []
  const variables: EncodedVariable[] = []
  const varTypes: EncodedVarType[] = []
  const varInstances: { [key: string]: EncodedVarInstance[] } = {}

  // Maps to track indices for deduplication
  const subscriptMap = new Map<string, number>()
  const variableMap = new Map<number, number>()
  const varTypeMap = new Map<string, number>()

  // Process each group
  for (const [groupKey, implVars] of Object.entries(input)) {
    const instances: EncodedVarInstance[] = []

    for (const implVar of implVars) {
      // Parse variable ID and name to extract base parts and subscripts
      const varIdInfo = parseSubscripts(implVar.varId)
      const varNameInfo = parseSubscripts(implVar.varName)

      // Add variable type if not already present
      let varTypeIndex = varTypeMap.get(implVar.varType)
      if (varTypeIndex === undefined) {
        varTypeIndex = varTypes.length
        varTypes.push(implVar.varType)
        varTypeMap.set(implVar.varType, varTypeIndex)
      }

      // Add variable if not already present
      let variableIndex = variableMap.get(implVar.varIndex)
      if (variableIndex === undefined) {
        variableIndex = variables.length
        variables.push({
          n: varNameInfo.base,
          i: varIdInfo.base,
          x: implVar.varIndex
        })
        variableMap.set(implVar.varIndex, variableIndex)
      }

      // Add subscripts if present
      let subscriptIndices: number[] | undefined
      let subscriptValues: number[] | undefined
      if (varIdInfo.subscripts.length > 0) {
        subscriptIndices = []
        subscriptValues = implVar.subscriptIndices || []

        for (let i = 0; i < varIdInfo.subscripts.length; i++) {
          const subscriptId = varIdInfo.subscripts[i]
          const subscriptName = varNameInfo.subscripts[i]

          let subscriptIndex = subscriptMap.get(subscriptId)
          if (subscriptIndex === undefined) {
            subscriptIndex = subscripts.length
            subscripts.push({
              n: subscriptName,
              i: subscriptId
            })
            subscriptMap.set(subscriptId, subscriptIndex)
          }

          subscriptIndices.push(subscriptIndex)
        }
      }

      // Create the encoded instance as a flat array
      const instance: EncodedVarInstance = [varTypeIndex, variableIndex]

      if (subscriptIndices) {
        // Add all subscript indices first, then all subscript values
        instance.push(...subscriptIndices, ...subscriptValues!)
      }

      instances.push(instance)
    }

    varInstances[groupKey] = instances
  }

  return {
    subscripts,
    variables,
    varTypes,
    varInstances
  }
}

/**
 * Decode impl variables from the efficient format back to the original structure.
 *
 * @param encoded The encoded representation.
 * @returns The original structure mapping keys to `ImplVar` arrays.
 */
export function decodeImplVars(encoded: EncodedImplVars): { [key: string]: ImplVar[] } {
  const result: { [key: string]: ImplVar[] } = {}

  for (const [groupKey, instances] of Object.entries(encoded.varInstances)) {
    const implVars: ImplVar[] = []

    for (const instance of instances) {
      const varType = encoded.varTypes[instance[0]]
      const variable = encoded.variables[instance[1]]

      let varId = variable.i
      let varName = variable.n

      // Add subscripts if present (elements 2+)
      if (instance.length > 2) {
        const subscriptIds: string[] = []
        const subscriptNames: string[] = []

        // First half are subscript indices, second half are subscript values
        const subscriptCount = (instance.length - 2) / 2
        const subscriptIndices = instance.slice(2, 2 + subscriptCount)

        for (const subscriptIndex of subscriptIndices) {
          const subscript = encoded.subscripts[subscriptIndex]
          subscriptIds.push(subscript.i)
          subscriptNames.push(subscript.n)
        }

        varId += `[${subscriptIds.join(',')}]`
        varName += `[${subscriptNames.join(',')}]`
      }

      const implVar: ImplVar = {
        varId,
        varName,
        varType,
        varIndex: variable.x,
        subscriptIndices: instance.length > 2 ? instance.slice(2 + (instance.length - 2) / 2) : undefined
      }

      implVars.push(implVar)
    }

    result[groupKey] = implVars
  }

  return result
}

/**
 * Parse subscript information from a variable ID or name.
 *
 * @param text The text to parse (either varId or varName).
 * @returns An object containing the base part and subscript parts.
 */
function parseSubscripts(text: string): { base: string; subscripts: string[] } {
  const bracketIndex = text.indexOf('[')
  if (bracketIndex === -1) {
    return { base: text, subscripts: [] }
  }

  const base = text.substring(0, bracketIndex)
  const subscriptText = text.substring(bracketIndex + 1, text.lastIndexOf(']'))
  const subscripts = subscriptText.split(',').map(s => s.trim())

  return { base, subscripts }
}
