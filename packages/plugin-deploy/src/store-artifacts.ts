// Copyright (c) 2025 Climate Interactive / New Venture Fund

import { execSync } from 'node:child_process'
import { existsSync, mkdirSync, cpSync, readFileSync, rmSync, writeFileSync } from 'node:fs'
import { join as joinPath } from 'node:path'

import type { BuildContext } from '@sdeverywhere/build'

import type { ResolvedPluginOptions } from './options'

// TODO: Make these configurable
const artifactsBranchName = 'artifacts'
const artifactsDir = 'artifacts'

/**
 * Simplified version of `BuildProduct` for use in the JSON metadata file.
 */
interface ProductSpec {
  /**
   * The name of the build product as used in the link in the top-level index page.  If undefined,
   * no link will be included in the top-level index page.
   */
  displayName?: string

  /** The path of the build product, relative to the base URL. */
  path: string
}

/**
 * Describes a branch build in the `artifacts` directory.  This is the shape of
 * the records in the `metadata/index.json` file.
 *
 * Example:
 * ```json
 * {
 *   "name": "main",
 *   "path": "branch/main",
 *   "products": {
 *     "app": {
 *       "displayName": "app",
 *       "path": "branch/main/app"
 *     },
 *     "checkReport": {
 *       "displayName": "checks",
 *       "path": "branch/main/extras/check-compare-to-base"
 *     },
 *     "checkBundle": {
 *       "path": "branch/main/extras/check-bundle.js"
 *     }
 *   },
 *   "lastModified": "2025-01-01T00:00:00Z"
 * }
 * ```
 */
interface BranchSpec {
  /** The name of the branch. */
  name: string
  /** The path of the branch build directory, relative to the base URL. */
  path: string
  /**
   * The build products that are available for this branch.  The keys of the record should be a short
   * name for the build product, used in the `index.json` file that is generated by the plugin.
   */
  products: Record<string, ProductSpec>
  /** The last modified date of the branch build products in ISO 8601 format. */
  lastModified: string
}

/**
 * Store build artifacts in the `artifacts` orphan branch.
 *
 * The `artifacts` directory contains build artifacts for all branches that
 * have been built. The directory structure is as follows:
 * ```
 *   artifacts/
 *   ├── index.html             # Top-level index.html file
 *   ├── latest/
 *   |   ├── index.html         # Main branch app
 *   |   ├── assets/            # Main branch assets
 *   ├── branch/
 *   |   ├── main/
 *   |   │   ├── app/           # Main branch app files
 *   |   │   └── extras/        # Main branch check bundles and reports
 *   |   ├── chris/1234-test/
 *   |   │   ├── app/           # Feature branch app files
 *   |   │   └── extras/        # Feature branch check bundles and reports
 *   |   └── feature/new-ui/
 *   |       ├── app/           # Feature branch app files
 *   |       └── extras/        # Feature branch check bundles and reports
 *   └── metadata/
 *       ├── bundles.json       # Listing of available bundles
 *       └── index.json         # Listing of available branch builds
 * ```
 *
 * @param context The build context.
 * @param options The resolved plugin options.
 * @param currentBranchName The current (sanitized/validated) git branch name.
 */
export function storeArtifacts(
  context: BuildContext,
  options: ResolvedPluginOptions,
  currentBranchName: string
): boolean {
  const deployDir = options.deployDir
  if (!existsSync(deployDir)) {
    context.log('error', `ERROR: Deployment directory '${deployDir}' does not exist`)
    return false
  }

  try {
    // Check if the project is already set up for GitHub Pages
    if (!checkGitHubPagesConfiguration(context)) {
      return false
    }

    context.log('info', `Storing artifacts for branch '${currentBranchName}'...`)

    // Configure git so that the commits in the following steps are attributed to
    // the current user
    const githubActor = process.env.GITHUB_ACTOR
    if (!githubActor) {
      context.log(
        'error',
        'Failed to get the GitHub username associated with the latest push (GITHUB_ACTOR is not defined); the artifacts branch will not be updated'
      )
      return false
    }
    execSync(`git config user.name "${githubActor}"`, { stdio: 'inherit' })
    execSync(`git config user.email "${githubActor}@users.noreply.github.com"`, { stdio: 'inherit' })

    // Check if `artifacts` branch exists
    let artifactsExists
    try {
      // This will fail if the branch doesn't exist yet, which is what we want.  This
      // assumes that the checkout action step in the `build` workflow was configured
      // with `fetch-depth: 0` to fetch full history.
      const branchRef = `refs/remotes/origin/${artifactsBranchName}`
      execSync(`git show-ref --verify --quiet ${branchRef}`, { stdio: 'ignore' })
      artifactsExists = true
    } catch (_) {
      artifactsExists = false
    }

    if (!artifactsExists) {
      // The orphan `artifacts` branch doesn't already exist, so create it now
      context.log('verbose', `Creating orphan '${artifactsBranchName}' branch...`)
      execSync(`git checkout --orphan ${artifactsBranchName}`, { stdio: 'inherit' })

      // By default, the new branch will inherit the contents of the current branch
      // (i.e., the contents will be git added), but we only want to keep the `artifacts`
      // directory, so unstage all cached files first
      execSync('git rm -rf --cached .', { stdio: 'inherit' })

      // Add a `.gitignore` file that ignores everything except the `artifacts` directory
      // and the `.gitignore` file itself
      const ignoredFiles = ['*', '!artifacts', '!artifacts/**', '!.gitignore']
      writeFileSync('.gitignore', ignoredFiles.join('\n'))
      execSync('git add .gitignore', { stdio: 'inherit' })
      context.log('verbose', `Created .gitignore file for '${artifactsBranchName}' branch`)
    } else {
      // Switch to the existing `artifacts` branch
      context.log('verbose', `Switching to existing '${artifactsBranchName}' branch...`)
      execSync(`git checkout ${artifactsBranchName}`, { stdio: 'inherit' })
    }

    // Remove existing branch directory if it exists
    const currentBranchDir = joinPath(artifactsDir, 'branch', currentBranchName)
    if (existsSync(currentBranchDir)) {
      context.log('verbose', `Removing existing branch directory '${currentBranchDir}'...`)
      rmSync(currentBranchDir, { recursive: true })
    }

    // Copy files from deploy directory to branch directory
    context.log('verbose', `Copying staged files from '${deployDir}' to '${currentBranchDir}'...`)
    cpSync(deployDir, currentBranchDir, { recursive: true })

    // Update `metadata/index.json` to include the current branch
    const currentBranchUrlPath = `branch/${currentBranchName}`
    const productSpecs: Record<string, ProductSpec> = {}
    for (const [name, product] of Object.entries(options.products)) {
      productSpecs[name] = {
        displayName: product.displayName,
        path: `${currentBranchUrlPath}/${product.dstPath}`
      }
    }
    const currentBranchSpec: BranchSpec = {
      name: currentBranchName,
      path: currentBranchUrlPath,
      products: productSpecs,
      lastModified: new Date().toISOString()
    }
    updateMetadata(context, options.baseUrl, currentBranchSpec)

    // For main branch, also copy app files to top-level `latest` directory
    // TODO: Make this step optional; this assumes we are deploying to a single server
    // that includes both production and development builds, but it would be better to
    // support separate servers for production and development builds
    // TODO: Make the main branch name configurable
    if (currentBranchName === 'main') {
      const stagedAppSrcDir = joinPath(deployDir, 'app')
      if (existsSync(stagedAppSrcDir)) {
        context.log('verbose', `Copying main branch app files to 'latest' directory...`)
        if (existsSync('latest')) {
          context.log('verbose', `Removing existing 'latest' directory...`)
          rmSync('latest', { recursive: true })
        }
        const stagedAppDstDir = joinPath(artifactsDir, 'latest')
        cpSync(stagedAppSrcDir, stagedAppDstDir, { recursive: true })
      }
    }

    // Squash commits so that we only keep the most recent 5 commits, but still preserve
    // the full contents of the `artifacts` branch.  This prevents the artifacts branch
    // from growing too large.  Note that we keep the latest build for each feature branch
    // indefinitely, so the the `artifacts` may eventually grow larger than desired.  In
    // this case, the user can manually remove old branch build artifacts to further
    // reduce the size of the `artifacts` branch.
    try {
      const commitCount = parseInt(execSync('git rev-list --count HEAD', { encoding: 'utf8' }).trim())
      if (commitCount > 5) {
        context.log(
          'verbose',
          `Found ${commitCount} commits, squashing older commits to reduce size of '${artifactsBranchName}' branch...`
        )
        // Get the hash of the 5th most recent commit (0-indexed, so skip 4)
        const fifthCommitHash = execSync('git rev-list --skip=4 --max-count=1 HEAD', { encoding: 'utf8' }).trim()
        // Reset soft to that commit (keeps all changes staged)
        execSync(`git reset --soft ${fifthCommitHash}`, { stdio: 'inherit' })
        // Amend the commit to squash everything into one
        execSync('git commit --amend --no-edit', { stdio: 'inherit' })
        context.log('verbose', 'Successfully squashed older commits')
      }
    } catch (_) {
      context.log('verbose', 'No commits found or error checking commit history, continuing...')
    }

    // Add all updated files in the `artifacts` directory to git
    execSync(`git add ${artifactsDir}`, { stdio: 'inherit' })

    // Check if there are changes to commit
    try {
      execSync('git diff --cached --quiet', { stdio: 'ignore' })
      context.log('verbose', 'No changes to commit')
    } catch (_) {
      // There are changes, so commit them
      const commitMessage = `build: update artifacts for branch ${currentBranchName}`
      execSync(`git commit -m "${commitMessage}"`, { stdio: 'inherit' })
      context.log('verbose', `Committed artifacts for branch '${currentBranchName}'...`)
    }

    // Push to remote (we do a force push since we may have rewritten history)
    context.log('info', `Pushing '${artifactsBranchName}' branch to remote...`)
    execSync(`git push --force origin ${artifactsBranchName}`, { stdio: 'inherit' })

    context.log('info', `✅ Successfully stored artifacts for branch '${currentBranchName}'`)
    return true
  } catch (error) {
    // TODO: Use `logError` here once it is available in `BuildContext` and pass error
    context.log('error', '❌ Error storing artifacts: ' + error.message)
    return false
  } finally {
    // Switch back to the original branch
    context.log('verbose', `Switching to original '${currentBranchName}' branch...`)
    execSync(`git checkout ${currentBranchName}`, { stdio: 'inherit' })
  }
}

/**
 * Check if GitHub Pages is configured for this repo.
 *
 * @param context The build context.
 * @returns true if GitHub Pages is configured, false otherwise.
 */
function checkGitHubPagesConfiguration(context: BuildContext): boolean {
  context.log('verbose', 'Checking if GitHub Pages is configured for this repo...')
  const ownerAndRepo = process.env.GITHUB_REPOSITORY
  const ghAccept = '"Accept: application/vnd.github+json"'
  const ghApiVersion = '"X-GitHub-Api-Version: 2022-11-28"'
  const ghPagesApiPath = `/repos/${ownerAndRepo}/pages`
  let isGitHubPagesSetup
  try {
    const pagesResponse = execSync(`gh api -H ${ghAccept} -H ${ghApiVersion} ${ghPagesApiPath}`)
    const pagesMetadata = JSON.parse(pagesResponse.toString())
    isGitHubPagesSetup = pagesMetadata.build_type === 'workflow'
    if (!isGitHubPagesSetup) {
      context.log(
        'verbose',
        'GitHub Pages is not configured to use workflow builds for this repo, but found existing configuration:'
      )
      context.log('verbose', '  build_type:    ' + pagesMetadata.build_type)
      context.log('verbose', '  source.branch: ' + pagesMetadata.source?.branch)
      context.log('verbose', '  source.path:   ' + pagesMetadata.source?.path)
    }
  } catch (_) {
    context.log('verbose', 'No existing GitHub Pages configuration found')
    isGitHubPagesSetup = false
  }
  if (isGitHubPagesSetup) {
    context.log('verbose', 'GitHub Pages is already configured for this repo')
    return true
  } else {
    // XXX: Ideally we would set up GitHub Pages automatically using the GitHub API,
    // but that requires "administration" permissions, which are not available for
    // the standard GITHUB_TOKEN.  Using a PAT would require even more effort to set
    // up, so for now, show instructions and fail the build.
    const msg: string[] = []
    msg.push('GitHub Pages is not configured for this repo')
    msg.push('For now, you must manually enable GitHub Pages as follows:')
    msg.push('  1. Go to the GitHub repository settings')
    msg.push('  2. In the sidebar, select "Pages"')
    msg.push('  3. Under "Build and deployment", change "Source" to "GitHub Actions"')
    msg.push('  4. In the tab bar, select "Actions"')
    msg.push('  5. Click on the most recent failed workflow run')
    msg.push('  6. In the upper right corner, click "Re-run jobs" then "Re-run all jobs"')
    context.log('error', msg.join('\n'))
    return false
  }
}

/**
 * Update the `metadata/index.json` file with the URL paths for the branch and its artifacts,
 * update the `metadata/bundles.json` file with the available bundles, and generate a top-level
 * `index.html` file that lists all available branch builds.
 */
function updateMetadata(context: BuildContext, baseUrl: string, currentBranchSpec: BranchSpec) {
  const metadataDir = joinPath(artifactsDir, 'metadata')
  const indexJsonFile = joinPath(metadataDir, 'index.json')
  const bundlesJsonFile = joinPath(metadataDir, 'bundles.json')

  // Create metadata directory if it doesn't exist
  mkdirSync(metadataDir, { recursive: true })

  // Read the existing `index.json` file if it exists
  let branchSpecs: BranchSpec[] = []
  if (existsSync(indexJsonFile)) {
    try {
      branchSpecs = JSON.parse(readFileSync(indexJsonFile, 'utf8'))
    } catch (_) {
      context.log('info', '⚠️ Could not parse existing index.json file, starting fresh')
      branchSpecs = []
    }
  }

  // Remove existing spec for this branch
  branchSpecs = branchSpecs.filter(spec => spec.name !== currentBranchSpec.name)

  // Add the new branch spec
  branchSpecs.push(currentBranchSpec)

  // Sort by lastModified (newest first)
  branchSpecs.sort((a, b) => b.lastModified.localeCompare(a.lastModified))

  // Write updated branch metadata to `metadata/index.json`
  writeFileSync(indexJsonFile, JSON.stringify(branchSpecs, null, 2))

  // Derive a `bundles.json` file from the branch specs.  The `bundles.json` file
  // must be in a specific format expected by that the model-check tool
  interface BundleSpec {
    name: string
    url: string
    lastModified: string
  }
  const bundleSpecs: BundleSpec[] = []
  for (const branchSpec of branchSpecs) {
    // TODO: For now we check for a specific build product with key `checkBundle`; we should
    // make this configurable instead of expecting a specific key format
    if (branchSpec.products.checkBundle) {
      bundleSpecs.push({
        name: branchSpec.name,
        // TODO: For now we store the full URL to the bundle in the `bundles.json` file using
        // the `PUBLISH_BASE_URL` environment variable.  Ideally we could use a relative URL
        // here instead of encoding the full URL in the `bundles.json` file, but
        // `@sdeverywhere/plugin-check` currently doesn't understand relative URLs.
        url: `${baseUrl}/${branchSpec.products.checkBundle}`,
        lastModified: branchSpec.lastModified
      })
    }
  }

  // Write updated bundle metadata to `metadata/bundles.json`
  writeFileSync(bundlesJsonFile, JSON.stringify(bundleSpecs, null, 2))

  context.log('verbose', `Updated metadata for branch '${currentBranchSpec.name}'`)

  // Generate top-level `index.html` file
  generateIndexHtml(context, branchSpecs)
}

/**
 * Generate a top-level index.html file that lists all available branch builds.
 */
function generateIndexHtml(context: BuildContext, branchSpecs: BranchSpec[]) {
  const indexHtmlPath = joinPath(artifactsDir, 'index.html')

  const latestBuildDate = branchSpecs.find(branch => branch.name === 'main')?.lastModified || ''

  function getBranchLinksHtml(branch: BranchSpec): string {
    const links: string[] = []
    for (const product of Object.values(branch.products)) {
      // Only include a link if the product has a display name
      if (product.displayName) {
        links.push(`<a href="${product.path}">${product.displayName}</a>`)
      }
    }
    return links.join('<span class="separator">|</span>')
  }

  const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Branch Builds</title>
  <style>
    body {
      font-family: monospace;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
      color: #000;
    }
    a, a:visited {
      color: #2563eb;
    }
    hr {
      margin: 20px 0;
      border: none;
      border-top: 1px solid #ccc;
    }
    .container {
      overflow: hidden;
    }
    .grid {
      display: grid;
      grid-template-columns: max-content 1fr;
      gap: 0 20px;
    }
    .header {
      padding: 8px 0;
      font-weight: 600;
    }
    .row {
      display: contents;
    }
    .cell {
      display: flex;
      flex-direction: column;
      padding: 8px 0;
    }
    .links {
      display: flex;
    }
    .separator {
      margin: 0 4px;
      color: #9ca3af;
    }
  </style>
  <script>
  function formatDate(isoString) {
    if (isoString.length === 0) {
      return 'n/a'
    }
    const date = new Date(isoString)
    const dateString = date.toLocaleDateString(undefined, { day: 'numeric', month: 'numeric', year: 'numeric' })
    const timeString = date.toLocaleTimeString(undefined, { hour12: false, hour: '2-digit', minute: '2-digit' })
    return \`\${dateString} at \${timeString}\`
  }

  // Format all dates on page load so that the time is displayed in the user's local timezone
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.date').forEach(span => {
      const timestamp = span.getAttribute('data-timestamp')
      if (timestamp) {
        span.textContent = formatDate(timestamp)
      }
    })
  })
  </script>
</head>
<body>
  <div class="container">
    <a href="latest">Latest production app</a>
    <br />
    (last updated: <span class="date" data-timestamp="${latestBuildDate}"></span>)
    <hr />
    <div class="grid">
      <div class="header">Branch</div>
      <div class="header">Last Updated</div>
${branchSpecs
  .map(
    branch => `
      <div class="row">
        <div class="cell">
          <span class="branch-name">${branch.name}</span>
          <div class="links">
            ${getBranchLinksHtml(branch)}
          </div>
        </div>
        <div class="cell">
          <span class="date" data-timestamp="${branch.lastModified}"></span>
        </div>
      </div>`
  )
  .join('')}
    </div>
  </div>
</body>
</html>`

  // Write the HTML content to the `index.html` file
  writeFileSync(indexHtmlPath, htmlContent)
  context.log('verbose', `Generated top-level index.html`)
}
